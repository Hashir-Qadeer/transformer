/*******************************************************************************
 * Copyright (c) 2017 David Gileadi and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     David Gileadi - initial API and implementation
 *******************************************************************************/
package org.eclipse.jdt.ls.core.internal.managers;

import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IConfigurationElement;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.ISafeRunnable;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.SafeRunner;
import org.eclipse.core.runtime.Status;
import org.eclipse.jdt.core.IClassFile;
import org.eclipse.jdt.ls.core.internal.IDecompiler;
import org.eclipse.jdt.ls.core.internal.JavaLanguageServerPlugin;
import org.eclipse.jdt.ls.core.internal.preferences.PreferenceManager;
import org.eclipse.jdt.ls.core.internal.preferences.Preferences;

public class DecompilerManager {

	public static final String DECOMPILED_HEADER = " // Failed to get sources. Instead, stub sources have been generated by the %s.";
	private static final String LF = "\n";
	private static final String EXTENSION_POINT_ID = "org.eclipse.jdt.ls.core.decompiler";
	private static final String CLASS = "class";
	private static final String ID = "id";
	private static final String NAME = "name";

	private final PreferenceManager preferenceManager;
	private DecompilerDescriptor decompilerDescriptor;

	public DecompilerManager(PreferenceManager preferenceManager) {
		this.preferenceManager = preferenceManager;
	}

	private static class DecompilerDescriptor {

		private final IConfigurationElement configurationElement;
		public final String id;
		public final String name;

		public DecompilerDescriptor(IConfigurationElement element) {
			configurationElement = element;
			id = configurationElement.getAttribute(ID);
			name = configurationElement.getAttribute(NAME);
		}

		public synchronized IDecompiler getDecompiler() {
			try {
				Object extension = configurationElement.createExecutableExtension(CLASS);
				if (extension instanceof IDecompiler) {
					return (IDecompiler) extension;
				} else {
					String message = "Invalid extension to " + EXTENSION_POINT_ID + ". Must implement org.eclipse.jdt.ls.core.internal.IDecompiler";
					JavaLanguageServerPlugin.logError(message);
				}
			} catch (CoreException e) {
				JavaLanguageServerPlugin.logException("Unable to create decompiler ", e);
			}
			return null;
		}
	}

	private static Set<DecompilerDescriptor> descriptors;

	private static synchronized Set<DecompilerDescriptor> getDecompilerDescriptors() {
		if (descriptors == null) {
			IConfigurationElement[] elements = Platform.getExtensionRegistry().getConfigurationElementsFor(EXTENSION_POINT_ID);
			descriptors = Stream.of(elements).map(e -> new DecompilerDescriptor(e)).collect(Collectors.toSet());
		}
		return descriptors;
	}

	/**
	 * Decompile the given class file if possible
	 *
	 * @param classFile
	 *            the class file to decompile
	 * @param monitor
	 * @return the decompiled code if successful, or <code>null</code> if
	 *         unsuccessful, or an empty string if canceled
	 */
	public String decompile(IClassFile classFile, IProgressMonitor monitor) {
		final IDecompiler decompiler = getDecompiler();

		if (monitor.isCanceled()) {
			return "";
		}

		final Map<String, Object> configuration = getConfiguration();
		final String[] resultValues = new String[1];
		SafeRunner.run(new ISafeRunnable() {
			@Override
			public void run() throws Exception {
				resultValues[0] = decompiler.decompile(classFile, configuration, monitor);
			}

			@Override
			public void handleException(Throwable ex) {
				IStatus status = new Status(IStatus.ERROR, JavaLanguageServerPlugin.PLUGIN_ID, IStatus.OK, "Error calling decompiler", ex);
				JavaLanguageServerPlugin.log(status);
			}
		});
		return prependHeader(resultValues[0], decompiler);
	}

	@SuppressWarnings("unchecked")
	private Map<String, Object> getConfiguration() {
		String decompilerId = preferenceManager.getPreferences().getDecompilerId();
		Map<String, Object> configuration = preferenceManager.getPreferences().getDecompilerConfiguration();
		if (configuration != null && configuration.get(decompilerId) instanceof Map) {
			configuration = (Map<String, Object>) configuration.get(decompilerId);
		}
		return configuration;
	}

	private IDecompiler getDecompiler() {
		IDecompiler decompiler = getDecompiler(preferenceManager.getPreferences().getDecompilerId());
		if (decompiler == null) {
			JavaLanguageServerPlugin.logError("Unable to load decompiler class for " + preferenceManager.getPreferences().getDecompilerId());
			decompiler = getDecompiler(Preferences.DECOMPILER_ID_DEFAULT);
		}
		if (decompiler == null) {
			JavaLanguageServerPlugin.logError("Unable to load decompiler class");
			return null;
		}
		return decompiler;
	}

	private IDecompiler getDecompiler(String decompilerId) {
		Set<DecompilerDescriptor> handlers = getDecompilerDescriptors();
		if (handlers.isEmpty()) {
			JavaLanguageServerPlugin.logError("No decompilers found");
			return null;
		}

		Optional<DecompilerDescriptor> handler = handlers.stream().filter(d -> decompilerId == null || decompilerId.equals(d.id)).findFirst();
		if (!handler.isPresent()) {
			JavaLanguageServerPlugin.logError("Unable to find decompiler " + decompilerId);
			return null;
		}

		this.decompilerDescriptor = handler.get();
		return this.decompilerDescriptor.getDecompiler();
	}

	private String prependHeader(String decompiledCode, IDecompiler decompiler) {
		if (decompiledCode != null) {
			String header = String.format(DECOMPILED_HEADER, getDecompilerName());
			decompiledCode = header + LF + decompiledCode;
		}
		return decompiledCode;
	}

	private String getDecompilerName() {
		if (this.decompilerDescriptor == null) {
			getDecompiler();
			if (this.decompilerDescriptor == null) {
				return null;
			}
		}
		String name = this.decompilerDescriptor.name;
		if (name == null) {
			name = this.decompilerDescriptor.id;
		}
		return name;
	}
}
