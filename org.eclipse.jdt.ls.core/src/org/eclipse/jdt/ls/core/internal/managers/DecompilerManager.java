/*******************************************************************************
 * Copyright (c) 2017 Microsoft Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     David Gileadi - initial API and implementation
 *******************************************************************************/
package org.eclipse.jdt.ls.core.internal.managers;

import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IConfigurationElement;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.ISafeRunnable;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.SafeRunner;
import org.eclipse.core.runtime.Status;
import org.eclipse.jdt.core.IClassFile;
import org.eclipse.jdt.ls.core.internal.Disassembler;
import org.eclipse.jdt.ls.core.internal.IDecompiler;
import org.eclipse.jdt.ls.core.internal.JavaLanguageServerPlugin;
import org.eclipse.jdt.ls.core.internal.preferences.PreferenceManager;

public class DecompilerManager {

	public static final String DECOMPILED_HEADER = " // Failed to get sources. Instead, stub sources have been generated by the %s.";
	public static final String DISASSEMBLER_HEADER_ADDITION = " // Implementation of methods is unavailable.\n";
	private static final String LF = "\n";
	private static final String EXTENSION_POINT_ID = "org.eclipse.jdt.ls.core.decompiler";
	private static final String CLASS = "class";
	private static final String ID = "id";
	private static final String NAME = "name";

	private final PreferenceManager preferenceManager;
	private DecompilerDescriptor decompilerDescriptor;
	private IDecompiler decompiler;

	public DecompilerManager(PreferenceManager preferenceManager) {
		this.preferenceManager = preferenceManager;
	}

	private static class DecompilerDescriptor {

		private final IConfigurationElement configurationElement;
		private IDecompiler decompiler;
		public final String id;
		public final String name;

		public DecompilerDescriptor(IConfigurationElement element) {
			configurationElement = element;
			id = configurationElement.getAttribute(ID);
			name = configurationElement.getAttribute(NAME);
			decompiler = null;
		}

		public synchronized IDecompiler getDecompiler() {
			if (decompiler == null) {
				try {
					Object extension = configurationElement.createExecutableExtension(CLASS);
					if (extension instanceof IDecompiler) {
						decompiler = (IDecompiler) extension;
					} else {
						String message = "Invalid extension to " + EXTENSION_POINT_ID + ". Must implement org.eclipse.jdt.ls.core.internal.IDecompiler";
						JavaLanguageServerPlugin.logError(message);
						return null;
					}
				} catch (CoreException e) {
					JavaLanguageServerPlugin.logException("Unable to create decompiler ", e);
					return null;
				}
			}
			return decompiler;
		}
	}

	private static Set<DecompilerDescriptor> descriptors;

	private static synchronized Set<DecompilerDescriptor> getDecompilerDescriptors() {
		if (descriptors == null) {
			IConfigurationElement[] elements = Platform.getExtensionRegistry().getConfigurationElementsFor(EXTENSION_POINT_ID);
			descriptors = Stream.of(elements).map(e -> new DecompilerDescriptor(e)).collect(Collectors.toSet());
		}
		return descriptors;
	}

	/**
	 * Decompile the given class file if possible
	 *
	 * @param classFile
	 *            the class file to decompile
	 * @param monitor
	 * @return the decompiled code if successful, or <code>null</code> if
	 *         unsuccessful, or an empty string if canceled
	 */
	public String decompile(IClassFile classFile, IProgressMonitor monitor) {
		IDecompiler decompiler = getDecompiler();
		if (decompiler == null) {
			JavaLanguageServerPlugin.logError("Unable to load decompiler class");
			return null;
		}

		if (monitor.isCanceled()) {
			return "";
		}

		final Map<String, Object> configuration = getConfiguration();
		final String[] resultValues = new String[1];
		SafeRunner.run(new ISafeRunnable() {
			@Override
			public void run() throws Exception {
				resultValues[0] = decompiler.decompile(classFile, configuration, monitor);
			}

			@Override
			public void handleException(Throwable ex) {
				IStatus status = new Status(IStatus.ERROR, JavaLanguageServerPlugin.PLUGIN_ID, IStatus.OK, "Error calling decompiler", ex);
				JavaLanguageServerPlugin.log(status);
			}
		});
		return prependHeader(resultValues[0]);
	}

	@SuppressWarnings("unchecked")
	private Map<String, Object> getConfiguration() {
		String decompilerId = preferenceManager.getPreferences().getDecompilerId();
		Map<String, Object> configuration = preferenceManager.getPreferences().getDecompilerConfiguration();
		if (configuration != null && configuration.get(decompilerId) instanceof Map) {
			configuration = (Map<String, Object>) configuration.get(decompilerId);
		}
		return configuration;
	}

	private IDecompiler getDecompiler() {
		if (this.decompiler != null) {
			return this.decompiler;
		}

		Set<DecompilerDescriptor> handlers = getDecompilerDescriptors();
		if (handlers.isEmpty()) {
			JavaLanguageServerPlugin.logError("No decompilers found");
			return null;
		}

		String decompilerId = preferenceManager.getPreferences().getDecompilerId();
		Optional<DecompilerDescriptor> handler = handlers.stream().filter(d -> decompilerId == null || decompilerId.equals(d.id)).findFirst();
		if (!handler.isPresent()) {
			JavaLanguageServerPlugin.logError("Unable to find decompiler " + decompilerId);
			return null;
		}

		this.decompilerDescriptor = handler.get();
		this.decompiler = this.decompilerDescriptor.getDecompiler();
		return this.decompiler;
	}

	private String prependHeader(String decompiledCode) {
		if (decompiledCode != null) {
			String header = String.format(DECOMPILED_HEADER, getDecompilerName());
			if (decompiler instanceof Disassembler) {
				header += DISASSEMBLER_HEADER_ADDITION;
			}
			decompiledCode = header + LF + decompiledCode;
		}
		return decompiledCode;
	}

	/**
	 * @return the name of the chosen decompiler, or its id if no name is provided
	 */
	private String getDecompilerName() {
		if (this.decompilerDescriptor == null) {
			getDecompiler();
			if (this.decompilerDescriptor == null) {
				return null;
			}
		}
		String name = this.decompilerDescriptor.name;
		if (name == null) {
			name = this.decompilerDescriptor.id;
		}
		return name;
	}
}
